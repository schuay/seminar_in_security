\section{Introduction}

The introduction should contain the background of the problem, why it is important, and what others have done to solve this problem. All related existing work should be properly described and referenced. The proposed solution should be briefly described, with explanations of how it is different from, and superior to, existing solutions. The last paragraph should be a summary of what will be described in each subsequent section of the paper.
\cite{waidner1989dining}

\section{The Dining Cryptographers Protocol}

% Adversary, model, assumptions, guarantees, goals...
% static and public key sharing graph, reliable network, honest participants?

\subsection{Protocol}

The initial idea of \acp{DCNetwork} was first proposed by \citeauthor{journals/joc/Chaum88}
at Crypto 1984 and subsequently published in \citeyear{journals/joc/Chaum88} \cite{journals/joc/Chaum88}.

\citeauthor{journals/joc/Chaum88} introduces the protocol with the following demonstration:
Consider three cryptographers seated around a round table at a restaurant.
After finishing dinner, they are informed that their check has already been paid\footnote{
We assume that the check has been paid exactly once.}.
Baffled, they wish to determine whether the payer was one of them (in which case
they do not want to reveal his identity) or if their dinner has been sponsored by the NSA.

They use the following protocol to answer this question.
In the first stage, each of them establishes a shared secret with each of his neighbors by flipping
a coin behind a menu such that only the two of them can see its outcome. The next stage
consists of announcements made by every participant. Each cryptographer
who has not paid then simply announces whether the two coin flips he participated
in landed on the same side or not, while the paying cryptographer says exactly the opposite.
Finally, they count the number of announced differences; if it is odd, then one of them has paid.
Otherwise, they determine that their dinner was paid by the NSA.

We now formalize this scenario: let the cryptographers be represented as the vertices 
$v_1, v_2, v_3$ in the complete graph $\mathbb{K}_3$. Each edge $e_{ij} = (v_i, v_j)$ represents a shared
key and is assigned a bit value $k(e_{ij}) = 0$ for ``heads'' and $k(e_{ij}) = 1$ for ``tails''. Without loss of generality,
let $v_1$ be the transmitting vertex, and let his message be $M_1 \in \{0, 1\}$ while $M_2, M_3 = 0$.
Every vertex $v_i$ now creates its announcement value $a(v_i)$ by combining all associated shared keys $k(e_{ij})$
as well as his message $M_i$ with XOR operations\footnote{
The sum modulo two which is sometimes used in the literature is equivalent to XOR.}
and broadcasts $a(v_i)$ to all other vertices in the network. Each $v_i$ is now able to
reconstruct the originally transmitted message by calculating
$M'_i = M_1 = a(v_1) \oplus \cdots \oplus a(v_3)$.

It may not be clear why $M'_i = M_1$, but it has an immediately intuitive explanation:
Note that each shared key $e_{ij}$ is included in $M'_i$ exactly twice.
Since $k(e_{ij}) = k(e_{ji})$ and $M_2, M_3 = 0$:

\begin{align*}
M'_i &= a(v_1) \oplus a(v_2) \oplus a(v_3) \\
     &= M_1 \oplus M_2 \oplus M_3 \\
     & \oplus (k(e_{12}) \oplus k(e_{21})) \\
     & \oplus (k(e_{13}) \oplus k(e_{31})) \\
     & \oplus (k(e_{23}) \oplus k(e_{32})) = m_1
\end{align*}

The \ac{DCProtocol} is unconditionally secure if each member is honest and performs the
protocol correctly. A short proof sketch considers a nonpaying cryptographer $v_1$
wishing to expose the person who paid. In the first case both of $v_1$'s shared keys are the same
(i.e. $a(v_1) = 0$) while $a(v_2) = 1$ and $a(v_3) = 0$. If $k(e_23) = k(e_12) = k(e_13)$, then $v_2$
is the payer, with $v_3$ paying otherwise. Since $k(e_23)$ takes each value with a probability
of $0.5$, $v_1$ also does not gain any information. In the second case, let $e_{12} = 1, e_{13} = 0, \text{ and } a(v_1) = 1$. If $a(v_2) = a(v_3) = 1$, the payer is $v_2$ if $e_{23} = 1$ and $v_3$ otherwise.
Likewise, if $a(v_2) = a(v_3) = 0$ then the payer is $v_2$ if $e_{23} = 0$ and $v_3$ otherwise.
Again, $v_1$ does not gain any information about which person has paid the bill.
A more general proof is available in \cite{journals/joc/Chaum88}.

The presented protocol is easily generalized to a larger number of participants $n > 3$ by simply
using the complete graph $\mathbb{K}_n$. Multi-bit message $M$ of length $|M| = j$
may be transmitted by running $j$ iterations of the \ac{DCProtocol}.  

\subsection{Definitions}

\subsubsection{Keysharing Graph}

An undirected connected graph $G = (V, E)$ with $|V| = n$ vertices $v_i \in V$ and $|E| = m$ edges $e_{ij} \in E$,
together with a function $k: E \rightarrow \{0, 1\}^p$ such that $k(e_{ij}) = k(e_{ji})$.
Each vertex represents a participant, and each edge $e_{ij}$ corresponds to a shared key of length $p$ with the value
$k(e_{ij})$.

\subsubsection{Anonymity Set}

Given a set of keys and their corresponding edges $K$ in a keysharing graph $G = (V, E)$, the anonymity set is the set of vertices in a connected component of $(V, E \setminus K)$ \cite{journals/joc/Chaum88}.

% TODO: Remove this section?

\subsection{Discussion}

The \ac{DCProtocol} exhibits some very desirable properties. For instance, it is one of the very few
protocols able to guarantee anonymity in the absence of a trusted party \cite{conf/eurocrypt/GolleJ04}.

It provides unconditional security when using unconditional secrecy channels\footnote{
If public key encryption is used, the \ac{DCProtocol} remains computationally secure.},
i.e. it remains secure even in the presence of a
strong attacker who can eavesdrop on all communications and has unlimited computational power.

Since all participants transmit an identical volume of data in each round the \ac{DCProtocol}
is completely immune to traffic analysis, unlike other anonymous messaging protocols such
as \acp{MixNet} \cite{journals/cacm/Chaum81}.

Malicious pooling of secret keys between two or more participants in order to
gain information about the message transmitter is called collusion.
Consider the anonymity set relative to the keysharing graph and the set of pooled key edges.
The attacker gains only the knowledge which anonymity set the transmitter belongs to \cite{journals/joc/Chaum88}. To completely expose the transmitter, the attacker would
have to own every single key shared by the transmitter.

It is possible to alter the key-sharing graph to accomodate varying requirements to
security and efficiency as long as the graph stays connected. Sparser graphs require fewer
shared keys, but make exposure through collusion less difficult. In the extreme case of
a ring topology in which each participant only shares keys with two other members, it is
possible to expose a sender by collusion of his two neighbors.

Besides sender-anonymity, it is also possible to achieve recipient-anonymity by
encrypting the message with the intended recipient's public key and having each
participant try to decrypt the message upon reception \cite{journals/joc/Chaum88}.

Similarly, it is possible to tie a message to a pseudonym by using public key cryptography
to sign it with the private key of a the desired pseudonym.

However, important questions remain as well. So far, we have simply assumed secret shared keys
to exist, but realistically these have to be generated and shared securely. Solutions
again mostly revolve around public key crypography and will be discussed further in
following sections.

Likewise, we have assumed the group membership and structure (i.e. the key-sharing graph $G$)
to remain static and known to all participants and ignored any issues of joining or leaving participants.

Another challenge is the prevention of collisions between message transmissions.
In this basic protocol, we have simply assumed that only a single participant transmits
in each round. Obviously, in practice some way of collision avoidance or recovery must exist.
Chaum suggests a simple retransmission scheme on detected collisions \cite{journals/joc/Chaum88}
while the \ac{DCNetwork} implementation \Dissent uses a shuffle protocol to agree on
a fixed transmission schedule \cite{journals/corr/abs-1004-3057}.

Performance and scalability are major issues as well. A \ac{DCNetwork} of $n$ participants requires $\Omega(n^3)$ messages per round, which obviously does not scale well to larger groups.
Much of the research on \acp{DCNetwork} has focused on this area; k-anonymous messaging \cite{von2003k},
\Dissent \cite{journals/corr/abs-1004-3057} and \Verdict \cite{corrigan2013proactively}
all attempt to make higher group memberships feasible.

We have already briefly mentioned the effect of accidental transmission collisions; what about the
case in which these are triggered on purpose by a malicious attacker intent on disrupting the
protocol? It is very difficult for \acp{DCNetwork} to deal with these denial of service attacks,
since one of their main goals is the guarantee of anonymity of senders. \citeauthor{journals/joc/Chaum88}
proposed an elaborate system of traps and checks in order to detect end ultimately exclude
disruptors from the protocol \cite{journals/joc/Chaum88}. \Dissent and \Verdict use the concept of
proactive accountability in order to recover from these attacks more efficiently \cite{journals/corr/abs-1004-3057,corrigan2013proactively}.


\section{Dealing with Disruptors}
\section{Achieving Scalability}

\section{Related Work}

This sections contains further publications similar to this topic. However, it can also be used to distinguish this paper to other publications.

Related work can also be used to give the reader references to publications which give more details about a topic.

\begin{comment}
Important points:

* Non-interactive
* Computationally/Unconditionally secure
* No central trusted party
* Shuffled send
* Security goals: integrity, anonymity, accountability (See dissent 2.3)
* Attack model (dissent 2.3)
* Assumptions, highlight difference between them (Faulty nodes never silent, ..., dissent 2.4)

Sections:

* 88: Base protocol
* 89: Disco (unconditional untraceability, computationally secure serviceability)
* 89: Waidner (Unreliable channel)
* 90: Detection of disruptors
* (03: Herbivore)
* 03: k-anonymity (maybe this is related work instead? weakens security goals to gain efficiency). Small DC subnets.
* 04: dc-revisited (proactive accountability. efficient cheater detection + recovery)
* 10: Dissent
* 13: Verdict

Definitions:

* Anonymity set
* Anonymity terms (cite def paper)
* Anonymity game (dissent [7])
* k-anonymity (k-anonymity)
* Robustness? (k-anonymity 3.3)
* (Partial, Full) Collusion
* Disruption
* Anytrust assumption
* Zero knowledge proofs

Attacks:

* Sybil (dissent [17])
* Sock puppetry (dissent [36])
* Traffic analysis (verdict [4, 34, 38])

Related work:

* Mix nets
* Crowds (dissent [29])
* CliqueNet (k-anon [17])
* Verifiable shuffles
* Group signatures, ring signatures
* Herbivore

Random notes:

* k-anonymous provide anonymity only when most members are honest (see dissent, related work)
* Herbivore provides anonymity only within small subgroups

\end{comment}

\section{Conclusion}

This summarizes what has been done and concludes based on the results. A description of future research should also be included.
