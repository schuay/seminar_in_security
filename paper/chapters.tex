\section{Introduction}

The introduction should contain the background of the problem, why it is important, and what others have done to solve this problem. All related existing work should be properly described and referenced. The proposed solution should be briefly described, with explanations of how it is different from, and superior to, existing solutions. The last paragraph should be a summary of what will be described in each subsequent section of the paper.
\cite{waidner1989dining}

\section{The Dining Cryptographers Protocol}

% Adversary, model, assumptions, guarantees, goals...
% static and public key sharing graph, reliable network, honest participants?

\subsection{Protocol}

The initial idea of \acp{DCNetwork} was first proposed by \citeauthor{journals/joc/Chaum88}
at Crypto 1984 and subsequently published in \citeyear{journals/joc/Chaum88} \cite{journals/joc/Chaum88}.

\citeauthor{journals/joc/Chaum88} introduces the protocol with the following demonstration:
Consider three cryptographers seated around a round table at a restaurant.
After finishing dinner, they are informed that their check has already been paid\footnote{
We assume that the check has been paid exactly once.}.
Baffled, they wish to determine whether the payer was one of them (in which case
they do not want to reveal his identity) or if their dinner has been sponsored by the NSA.

They use the following protocol to answer this question.
In the first stage, each of them establishes a shared secret with each of his neighbors by flipping
a coin behind a menu such that only the two of them can see its outcome. The next stage
consists of announcements made by every participant. Each cryptographer
who has not paid then simply announces whether the two coin flips he participated
in landed on the same side or not, while the paying cryptographer says exactly the opposite.
Finally, they count the number of announced differences; if it is odd, then one of them has paid.
Otherwise, they determine that their dinner was paid by the NSA.

We now formalize this scenario: let the cryptographers be represented as the vertices 
$v_1, v_2, v_3$ in the complete graph $\mathbb{K}_3$. Each edge $e_{ij} = (v_i, v_j)$ represents a shared
key and is assigned a bit value $k(e_{ij}) = 0$ for ``heads'' and $k(e_{ij}) = 1$ for ``tails''. Without loss of generality,
let $v_1$ be the transmitting vertex, and let his message be $M_1 \in \{0, 1\}$ while $M_2, M_3 = 0$.
Every vertex $v_i$ now creates its announcement value $a(v_i)$ by combining all associated shared keys $k(e_{ij})$
as well as his message $M_i$ with XOR operations\footnote{
The sum modulo two which is sometimes used in the literature is equivalent to XOR.}
and broadcasts $a(v_i)$ to all other vertices in the network. Each $v_i$ is now able to
reconstruct the originally transmitted message by calculating
$M'_i = M_1 = a(v_1) \oplus \cdots \oplus a(v_3)$.

It may not be clear why $M'_i = M_1$, but it has an immediately intuitive explanation:
Note that each shared key $e_{ij}$ is included in $M'_i$ exactly twice.
Since $k(e_{ij}) = k(e_{ji})$ and $M_2, M_3 = 0$:

\begin{align*}
M'_i &= a(v_1) \oplus a(v_2) \oplus a(v_3) \\
     &= M_1 \oplus M_2 \oplus M_3 \\
     & \oplus (k(e_{12}) \oplus k(e_{21})) \\
     & \oplus (k(e_{13}) \oplus k(e_{31})) \\
     & \oplus (k(e_{23}) \oplus k(e_{32})) = m_1
\end{align*}

The \ac{DCProtocol} is unconditionally secure if each member is honest and performs the
protocol correctly. A short proof sketch considers a nonpaying cryptographer $v_1$
wishing to expose the person who paid. In the first case both of $v_1$'s shared keys are the same
(i.e. $a(v_1) = 0$) while $a(v_2) = 1$ and $a(v_3) = 0$. If $k(e_23) = k(e_12) = k(e_13)$, then $v_2$
is the payer, with $v_3$ paying otherwise. Since $k(e_23)$ takes each value with a probability
of $0.5$, $v_1$ also does not gain any information. In the second case, let $e_{12} = 1, e_{13} = 0, \text{ and } a(v_1) = 1$. If $a(v_2) = a(v_3) = 1$, the payer is $v_2$ if $e_{23} = 1$ and $v_3$ otherwise.
Likewise, if $a(v_2) = a(v_3) = 0$ then the payer is $v_2$ if $e_{23} = 0$ and $v_3$ otherwise.
Again, $v_1$ does not gain any information about which person has paid the bill.
A more general proof is available in \cite{journals/joc/Chaum88}.

The presented protocol is easily generalized to a larger number of participants $n > 3$ by simply
using the complete graph $\mathbb{K}_n$. Multi-bit message $M$ of length $|M| = j$
may be transmitted by running $j$ iterations of the \ac{DCProtocol}.  

\subsection{Definitions}

\subsubsection{Keysharing Graph}

An undirected connected graph $G = (V, E)$ with $|V| = n$ vertices $v_i \in V$ and $|E| = m$ edges $e_{ij} \in E$,
together with a function $k: E \rightarrow \{0, 1\}^p$ such that $k(e_{ij}) = k(e_{ji})$.
Each vertex represents a participant, and each edge $e_{ij}$ corresponds to a shared key of length $p$ with the value
$k(e_{ij})$.

\subsubsection{Anonymity Set}

Given a set of keys and their corresponding edges $K$ in a keysharing graph $G = (V, E)$, the anonymity set is the set of vertices in a connected component of $(V, E \setminus K)$ \cite{journals/joc/Chaum88}.

% TODO: Remove this section?

\subsection{Discussion}

The \ac{DCProtocol} exhibits some very desirable properties. For instance, it is one of the very few
protocols able to guarantee anonymity in the absence of a trusted party \cite{conf/eurocrypt/GolleJ04}.

It provides unconditional security when using unconditional secrecy channels\footnote{
If public key encryption is used, the \ac{DCProtocol} remains computationally secure.},
i.e. it remains secure even in the presence of a
strong attacker who can eavesdrop on all communications and has unlimited computational power.

Since all participants transmit an identical volume of data in each round the \ac{DCProtocol}
is completely immune to traffic analysis, unlike other anonymous messaging protocols such
as \acp{MixNet} \cite{journals/cacm/Chaum81}.

Malicious pooling of secret keys between two or more participants in order to
gain information about the message transmitter is called collusion.
Consider the anonymity set relative to the keysharing graph and the set of pooled key edges.
The attacker gains only the knowledge which anonymity set the transmitter belongs to \cite{journals/joc/Chaum88}. To completely expose the transmitter, the attacker would
have to own every single key shared by the transmitter.

It is possible to alter the key-sharing graph to accomodate varying requirements to
security and efficiency as long as the graph stays connected. Sparser graphs require fewer
shared keys, but make exposure through collusion less difficult. In the extreme case of
a ring topology in which each participant only shares keys with two other members, it is
possible to expose a sender by collusion of his two neighbors.

Besides sender-anonymity, it is also possible to achieve recipient-anonymity by
encrypting the message with the intended recipient's public key and having each
participant try to decrypt the message upon reception \cite{journals/joc/Chaum88}.

Similarly, it is possible to tie a message to a pseudonym by using public key cryptography
to sign it with the private key of a the desired pseudonym.

However, important questions remain as well. So far, we have simply assumed secret shared keys
to exist, but realistically these have to be generated and shared securely. Solutions
again mostly revolve around public key crypography and will be discussed further in
following sections.

Likewise, we have assumed the group membership and structure (i.e. the key-sharing graph $G$)
to remain static and known to all participants and ignored any issues of joining or leaving participants.

Another challenge is the prevention of collisions between message transmissions.
In this basic protocol, we have simply assumed that only a single participant transmits
in each round. Obviously, in practice some way of collision avoidance or recovery must exist.
Chaum suggests a simple retransmission scheme on detected collisions \cite{journals/joc/Chaum88}
while the \ac{DCNetwork} implementation \Dissent uses a shuffle protocol to agree on
a fixed transmission schedule \cite{journals/corr/abs-1004-3057}.

Performance and scalability are major issues as well. A \ac{DCNetwork} of $n$ participants requires $\Omega(n^3)$ messages per round, which obviously does not scale well to larger groups.
Much of the research on \acp{DCNetwork} has focused on this area; k-anonymous messaging \cite{von2003k},
\Dissent \cite{journals/corr/abs-1004-3057} and \Verdict \cite{corrigan2013proactively}
all attempt to make higher group memberships feasible.

We have already briefly mentioned the effect of accidental transmission collisions; what about the
case in which these are triggered on purpose by a malicious attacker intent on disrupting the
protocol? It is very difficult for \acp{DCNetwork} to deal with these denial of service attacks,
since one of their main goals is the guarantee of anonymity of senders. \citeauthor{journals/joc/Chaum88}
proposed an elaborate system of traps and checks in order to detect end ultimately exclude
disruptors from the protocol \cite{journals/joc/Chaum88}. \Dissent and \Verdict use the concept of
proactive accountability in order to recover from these attacks more efficiently \cite{journals/corr/abs-1004-3057,corrigan2013proactively}.

\section{k-anonymous Messaging}

% Definitions: k-anonymity, honest/faulty participant (dissent)
% Equivalence member, node, participant

k-anonymous message transmission is a modification of the \ac{DCProtocol} which was published in \citeyear{von2003k} by \citeauthor{von2003k}. Its main contributions are better scalability properties through relaxation
of the core anonymity goals \cite{von2003k}.

Unlike \acp{DCNetwork} which guarantee that an attacker monitoring all traffic cannot gain
any information which of the $n$ participants was the sender, \citeauthor{von2003k} introduce
the concept of sender and receiver k-anonymity. A protocol is said to be sender k-anonymous
if each message sent by an honest party cannot be distinguished from those sent by at least $k - 1$
other honest parties \cite{von2003k}. While full anonymity is required in some cases, in others
k-anonymity suffices even for small values of $k$. For example, 2-anonymity and 3-anonymity would invalidate, respectively, a criminal and a civil charge in the United States legal system.

The attack model consists of an adversary with polynomially bounded computational power
who can monitor all communications and
has control over up to $\frac{n}{2}$ participants\footnote{
These faulty participants must be chosen once at the beginning of the protocol and may not
be altered during its execution, i.e. the adversary is non-adaptive.}. The adversary may not affect
the delivery of messages, and communications between participants are always delivered.
A trusted public-key infrastructure is assumed to exist\footnote{Public-key cryptography is
required for the special case of handling non-participation by faulty nodes which is not discussed further
in this context.}.

\subsection{Protocol}

k-anonymous messaging relies on a combination of a secure multiparty sum algorithm
together with zero-knowledge proofs and Pedersen commitments.

A secure multiparty sum protocol allows a group of participants to collaboratively
compute the sum of their respective inputs without learning anything about the
inputs of other group members. Consider participants $P_1, \ldots, P_n$, each with
inputs $X_i$ taken from the additive group of integers modulo m $\mathbb{Z}_m$.
Each participant splits his input into $n$ values $s_{i,1}, \ldots, s_{i,n}$ such that $\sum_j s_{i,j} = X_i$
and then sends element $s_{i,j}$ to participant $P_j$. Every $P_j$ then forms
$s'_i = \sum_i s_{i,j}$, broadcasts $s'_i$, and computes the final sum $X = \sum_i s'_i = \sum_i X_i$.

Zero-knowledge proofs allow a prover to convince a verifier of some statement while
giving the verifier no additional knowledge. \citeauthor{chaum1987demonstrating}
present a protocol demonstrating knowledge of the discrete logarithm of $x = h^r \mod p$
where $q$ divides $p - 1$ and $p,q$ are prime in \cite{chaum1987demonstrating}.

The Pederson commitment \cite{pedersen1992non} allows party $P$ to publically commit
to a value $s$ by publishing $C_r(s)$ such that a) $P$ is bound to his commitment, i.e. he cannot later
claim an $s' \neq s$ to be the original value, and b) the commitment does not reveal
any information about $s$. This commitment scheme is based on the difficulty of computing discrete
logarithms, and has the additionally useful property that $C_{r1}(s_1) \cdot C_{r2}(s_2) = C_{r1 + r2}(s_1 + s_2)$.

In k-anonymous messaging, the group consisting of $n$ members is first partitioned
into subgroups of size $M = O(k)$ such that with high probability $k$ members of each group
are honest. This is accomplished by combining the original assumptation that at least
$\frac{n}{2}$ members are honest with a Chernoff Bound to limit the probability that
any subgroup contains less than $k$ honest members. The input of each member is
a tuple $X_i = (m_i, g_i)$, where $m_i$ is the message to be transmitted, and
$g_i$ identifies the group of the intended recipient. Each subgroup then runs
$2M$ iterations of the multiparty sum protocol, using commitments to verify the
correctness of the computed sums in order to counteract faulty members. Zero knowledge
proofs are used to guarantee fairness in the sense that each participant may only transmit
in exactly one of the $2M$ iterations. Further details of the protocol are available in
\cite{von2003k}.

\subsection{Discussion}

Recall that in a \ac{DCNetwork}, the count of messages sent is $\Omega(n^3)$ in any case.
In a k-anonymous messaging round with exclusively honest participants, $O(k^2)$ messages are transmitted.
Faulty members are detected with high probability, and as such
honest rounds are treated as the standard case in efficiency analysis.
Note that $k$ is unrelated to $n$, vastly improving the protocol's scalability.
On the other hand, it is possible to increase $k$ up to $n$ if needed.

Unlike the base \ac{DCNetwork}, adversaries are restricted to polynomially bound computational
power in order to facilitate the use of public-key cryptography, Pedersen commitments, and zero-knowledge
proofs. Likewise, the number of faulty participants is limited to a constant fraction in order
to bound the probability of any subgroup containing less than $k$ honest members.

In contrast to the base \ac{DCProtocol}, k-anonymous messaging provides improved scalability and
a novel way of detecting faulty members. As a trade-off, anonymity guarantees are relaxed
and provide k-anonymity only. It is especially relevant for cases in which group sizes are high,
and complete anonymity is not required. \citeauthor{von2003k} especially highlight use over the
Internet as particularly efficient because of the low round complexity in a k-anonymity protocol.

\section{Dissent}



\section{Verdict}

\section{Related Work}

This sections contains further publications similar to this topic. However, it can also be used to distinguish this paper to other publications.

Related work can also be used to give the reader references to publications which give more details about a topic.

\begin{comment}
Important points:

* Non-interactive
* Computationally/Unconditionally secure
* No central trusted party
* Shuffled send
* Security goals: integrity, anonymity, accountability (See dissent 2.3)
* Attack model (dissent 2.3)
* Assumptions, highlight difference between them (Faulty nodes never silent, ..., dissent 2.4)

Sections:

* 88: Base protocol
* 89: Disco (unconditional untraceability, computationally secure serviceability)
* 89: Waidner (Unreliable channel)
* 90: Detection of disruptors
* (03: Herbivore)
* 03: k-anonymity (maybe this is related work instead? weakens security goals to gain efficiency). Small DC subnets.
* 04: dc-revisited (proactive accountability. efficient cheater detection + recovery)
* 10: Dissent
* 13: Verdict

Definitions:

* Anonymity set
* Anonymity terms (cite def paper)
* Anonymity game (dissent [7])
* k-anonymity (k-anonymity)
* Robustness? (k-anonymity 3.3)
* (Partial, Full) Collusion
* Disruption
* Anytrust assumption
* Zero knowledge proofs

Attacks:

* Sybil (dissent [17])
* Sock puppetry (dissent [36])
* Traffic analysis (verdict [4, 34, 38])

Related work:

* Mix nets
* Crowds (dissent [29])
* CliqueNet (k-anon [17])
* Verifiable shuffles
* Group signatures, ring signatures
* Herbivore

Random notes:

* k-anonymous provide anonymity only when most members are honest (see dissent, related work)
* Herbivore provides anonymity only within small subgroups

\end{comment}

\section{Conclusion}

This summarizes what has been done and concludes based on the results. A description of future research should also be included.
